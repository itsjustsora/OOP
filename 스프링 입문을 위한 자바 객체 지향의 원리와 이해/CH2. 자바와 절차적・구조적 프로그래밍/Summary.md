### 자바 프로그램의 개발과 구동

| 현실 세계 | 가상 세계(자바 월드) |
| --- | --- |
| 소프트웨어 개발 도구 | JDK - 자바 개발 도구
JVM용 소프트웨어 개발 도구 |
| 운영체제 | JVM용 OS |
| 하드웨어 - 물리적 컴퓨터 | 가상의 컴퓨터 |


**JDK / JDK / JVM의 관계**

![Untitled](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fc00klf%2FbtqAjMzLyF2%2F6sU1VGp5vqAYIPLsXpakpK%2Fimg.png)

- **JDK**

  자바 소스 컴파일러인 javac.exe 포함

- **JRE**

  자바 프로그램 실행기인 java.exe 포함

- **JVM**
  
---
**객체 지향 프로그램의 메모리 사용 방식**

![Untitled](https://juneyr.dev/static/c9c7b633106075496d411b8b9e8cd1aa/c3eac/memory.png)

![Untitled](https://juneyr.dev/static/f8d22b2e7709ac265058c2f4f3be61ea/c3eac/memory-2.png)

**자바에 존재하는 절차적/구조적 프로그래밍의 유산**

**[절차적]**

자바에서 *goto를 사용하지 못하게 한 이유는 무엇일까?*

goto를 사용하게 되면 프로그램의 실행 순서를 이리저리 이동할 수 있게 된다. 그러한 이동이 잦아지면 소스를 이리저리 따라가면서 프로그램을 이해해야 하는데 쉽지 않다.

**[구조적 프로그래밍]**

- 함수를 쓰라는 의미. 함수를 쓰면 좋은 이유는 우선 중복 코드를 한 곳에 모아 관리할 수 있고 논리를 함수 단위로 분리해서 이해하기 쉬운 코드를 작성할 수 있기 때문이다.
- 구조적 프로그래밍의 지침 중에는 공유 사용 시 문제가 발생하기 쉬운 전역 변수보다는 지역 변수를 쓰라는 것도 있다.

**[함수와 메서드는 무엇이 다를까?]**

- 절차적/구조적 프로그래밍에서는 함수, 객체 지향에서는 메서드라고 구분해서 부를 뿐 같은 의미이다.
- 함수는 클래스나 객체와 아무 관계가 없지만 메서드는 반드시 클래스 정의 안에 존재해야 한다.

---
**다시 보는 main() 메서드 : 메서드 스택 프레임**

```java
public class Start {
	public static void main(String[] args) {
		System.out.println("Hello OOP!");
	}
}
```

- **JRE**는 먼저 프로그램 안에 main() 메서드가 있는지 확인한 후 존재가 확인되면 프로그램 실행을 위한 사전 준비에 착수한다.
- JRE가 가상의 기계인 **JVM**을 부팅하면 JVM은 목적 파일을 받아 그 목적 파일을 실행한다. JVM이 먼저 하는 일은 전처리라고 하는 과정이다.
    - ***java.lang 패키지***를 T 메모리의 스태틱 영역에 가져다 놓는다.
    - 개발자가 작성한 ***모든 클래스와 임포트 패키지*** 역시 스태틱 영역에 가져다 놓는다.
- 여는 중괄호({)를 만날 때마다 스택 프레임이 하나씩 생기므로 **main() 메서드의 스택 프레임**이 스택 영역에 할당된다.
- 메서드의 인자 args를 저장할 **변수 공간**을 **스택 프레임의 맨 밑에 확보**해야 한다.
- System.out.println() 구문이 코드 실행 공간에서 실행되면 GPU에 화면 출력을 의뢰하게 된다. 이때 데이터 저장 공간이 T메모리에는 아무런 변화가 없다.
- main() 메서드가 끝나면 닫는 중괄호(})를 만나 스택 프레임이 소멸되고 JRE는 JVM을 종료하고 JRE 자체도 운영체제 상의 메모리에서 사라진다.


**블록 구문과 메모리: 블록 스택 프레임**

```java
public class Start3 {
	public static void main(String[] args) {
		int i = 10;
		int k = 20;

		if(i = 10) {
			int m = k + 5;
			k = m;
		} else {
			int p = k + 10;
			k = p;
		}
	}
}
```

- if ~ else 블록 중 위의 블록이 실행되면 메서드의 스택 프레임 안에 if(true) 스택 프레임이 할당된다.
- T 메모리 소멸 → JVM 가동 중지 → JRE가 사용했던 시스템 자원 운영체제에 반납
  
  
**지역 변수와 메모리**

- 지역 변수는 스택 프레임 안에 존재하고 스택 프레임이 사라지면 함께 사라진다.
- 클래스 멤버 변수는 스태틱 영역에 한번 생성되면 JVM이 종료될 때까지 고정된(static) 상태로 그 자리를 지킨다.
- 객체 멤버 변수는 힙에서 객체와 함께 가비지 컬렉터에 의해 사라진다.
  
**전역 변수를 사용하지 말아야 하는 이유**

프로젝트 규모에 따라 코드가 커지면서 여러 메서드에서 전역 변수의 값을 변경하기 시작하면 T메모리로 추적하지 않는 이상 전역 변수에 저장돼 있는 값을 파악하기 쉽지 않기 때문이다. 다만 읽기 전용으로 값을 공유해서 전역 상수로 쓰는 것은 적극 추천한다.

---
**멀티 스레드 / 멀티 프로세스의 이해**

![Untitled](https://juneyr.dev/static/9e01655dbe6e7b743dc5bf5d02589787/c3eac/multi-thread.png)

- 멀티 스레드의 T 메모리 모델은 스택 영역을 스레드 개수만큼 분할해서 쓰는 것이다.
- 멀티 프로세스 대비 메모리를 적게 사용할 수 있는 구조다.
- 멀티 스레드에서 전역 변수 사용의 문제점
    - 쓰기 가능한 전역 변수를 사용하게 되면 스레드 안전성이 깨진다.
    - 이를 보완하기 위해 lock을 걸 수 있지만 그 순간 멀티 스레드의 장점은 버린 것과 같다.



![Untitled](https://juneyr.dev/static/60e916a25b7830ec2a4b0896ed958480/c3eac/multi-process.png)

- 멀티 프로세스는 다수의 데이터 저장 영역, 즉 다수의 T 메모리를 갖는 구조다.
- 각 프로세스마다 각자의 T 메모리가 있고 각자 고유의 공간이므로 서로 참조할 수 없다.

---

*그림 출처*. [https://juneyr.dev/java-things](https://juneyr.dev/java-things)